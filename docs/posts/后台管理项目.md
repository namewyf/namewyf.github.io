---
date: 2024-11-11
category:
  - CategoryC
tag:
  - tag E
sticky: 20
---

# 后台管理项目
基于elementui、vue3、koa的后台管理项目
<!-- more -->
## 第二章 前端架构设计

### 2-8 axios二次封装（下）
构造好request的封装函数后在main.js里进行全局挂载之后才能在组件进行全局使用
```js
import request from './uitils/request';
app.config.globalProperties.$request = request
```
>在js里request和request()是不同的，request是将request函数本身赋值给app.config.globalProperties.$request
如果说是request()则是先执行request然后将返回值赋值给app.config.globalProperties.$request

封装完成后，就能在组件里面调用了
```js
  mounted() {
    this.$request({
      method:'get',
      url:'/login',
      data:{
        name:'jack'
      }
    }).then((res)=>{
       console.log("res=",res);
    })
  }
```

为了更加方便的进行调用，我们还可以把request函数转换成一个对象，这个对象里有各种请求的方法  

request.js
```js
['get', 'post', 'put', 'delete', 'patch'].forEach((item) => {
    request[item] = (url, data, options) => {//options可以对请求的参数做一些额外的拓展，比如可以传mock:true,或者loading之类的东西
        return request({
            url,
            data,
            method: item,
            ...options
        })
    }
})
```
>1. 这个地方非常巧妙地把函数request转换为对象request，并且把多个属性添加到request对象里，属性的值是函数
>2. options可以对请求的参数做一些额外的拓展，比如可以传mock:true,或者loading:true之类的东西

login.vue
```js
  mounted() {
    this.$request.get('/login',{name:'jack'}).then((res)=>{
      console.log(res);
    })
  }
```

### 2-9 storage二次封装

#### storage的使用场景：  
1. 在用户进行登陆的时候，用来存储服务器发来的jwt(token)
2. 跨组件的数据共享，如果使用vuex只是一个数据共享，只是一个数据的管理，数据都只是存储在js内存里，当页面刷新的时候数据都会销毁，所以我们一般使用vuex结合local storage去做存储和管理
3. storage比cookie存储的数据的量更多的

#### local storage封装的目的：

定义不同的命名空间对变量名进行隔离，防止不同命名的冲突,但是local storage只能存储字符串，所以需要把对象转化为字符串再存储，这时候就可以使用JSON.stringify()方法来序列化对象，然后通过JSON.parse()方法来还原对象
>序列化（Serialization）是将数据结构或对象的状态转换为一个可存储或传输的格式的过程

>注意json语法的对象里面的key必须要加双引号(对，是必须是双引号)


utils/storage.js
```js
// Storage的封装

import config from "../config";
export default {
    setItem(key, val) {
        let storage = this.getStorage()
        storage[key] = val
        window.localStorage.setItem(config.namespace, JSON.stringify(storage));
    },
    getItem(key) {
        return this.getStorage()[key]
    },
    getStorage() {
        return JSON.parse(window.localStorage.getItem(config.namespace) || '{}')
    },
    clearItem(key) {
        let storage = this.getStorage()
        delete storage[key]//delete 是一个操作符，用于删除对象的属性
        window.localStorage.setItem(config.namespace, JSON.stringify(storage));
    },
    clearAll() {
        window.localStorage.clear()
    }
}
```

config/index.js
```js
export default {
    namespace: 'manager'
}
```

App.vue
```js
    mounted(){
      this.$storage.setItem('name','Tom')
    }
```

>注：在开发者工具中查看 localStorage 中存储的值时,确实会以对象的形式显示,即使你使用 JSON.stringify() 将其转换为字符串存储。  
这是因为开发者工具会尝试解析和显示存储的值的实际数据结构,而不仅仅是字符串形式。虽然 localStorage 中存储的是字符串,但开发者工具会尝试将其转换回原始的数据结构以便于查看和调试。  
所以即使你将对象转换为 JSON 字符串存储,开发者工具还是会尽量还原成对象的形式显示。这是开发者工具的一个特性,旨在为开发者提供更直观的数据查看体验。  
但实际上,在 localStorage 中存储的确是字符串形式的 JSON 数据。当你从 localStorage 中读取数据时,需要使用 JSON.parse() 将字符串转换回原始的对象或数组。  
总之,开发者工具的显示行为和 localStorage 的实际存储方式是不同的。这是开发者工具的一个特性,旨在为开发者提供更友好的数据查看体验。  

### 2-10 主页结构布局

#### 引入全局的样式文件
放在assets目录下，目录如下
-assets
--style
---index.scss
---reset.css
--logo.png

index.scss里是有一些公共的样式，是针对本项目设置的一些公共样式和业务样式
>reset.css 文件, 类似于base.css, 是一个用于重置浏览器默认样式的样式表。其主要目的是消除不同浏览器之间对HTML元素默认样式的差异，以确保网页在各种浏览器中呈现一致的外观

App.vue里面引入：
```css
<style lang="scss">
/* style样式要通过@import的方式进行引入 */
/* 不过import已经被弃用了ys 的vite-plugin-sass-glob-resolver插件所取代，
所以这里不再使用import，而是使用@use，
@use与@import的区别是，@import会引入所有样式，而@use只会引入用到的样式，
所以@use性能更好，但需要使用css变量， */
@use "./assets/style/index.scss";
@use "./assets/style/reset.css";
</style>
```
这里要加lang="scss"

vite.config.js
```js
  //配置 Vite 项目中 SCSS 预处理器的 API 类型，指定使用现代编译器。这有助于确保 SCSS 文件在编译时使用最新的编译方式，提高兼容性和性能。
  css: {
    preprocessorOptions: {
      scss: {
        api: "modern-compiler" // or 'modern'
      }
    }
  },
```

Home.vue
```js
<template>
  <div class="basic-layout">
    <!-- 导航栏 -->
    <div class="nav-side"></div>
    <!-- 右侧内容 -->
    <div class="content-right">
      <!-- 顶部导航栏 -->
      <div class="nav-top">
        <div class="bread">
          面包屑
        </div>
        <div class="user-info">
          用户名
        </div>
      </div>
      <div class="wrapper">
        <div class="main-page">
          <router-view></router-view>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'home',
  components: {},
  data() {
    return {}
  },
  methods: {},
  mounted() { }
}
</script>

<style lang="scss">
.basic-layout {
  position: relative;

  .nav-side {
    position: fixed;
    width: 200px;
    height: 100vh;
    background-color: #001529;
    color: #fff; //文字颜色为白色
    overflow-y: auto; //滚动条
    transition: width 0.5s //宽度变化的动画
  }

  .content-right {
    margin-left: 200px;

    .nav-top {
      height: 50px;
      line-height: 50px;
      display: flex;
      justify-content: space-between; //控制两端对齐
      border-bottom: 1px solid #ddd;
      padding: 0 20px;
    }

    .wrapper {
      background: #eef0f3;
      padding: 20px;
      height: calc(100vh - 50px); //计算属性

      .main-page {
        background: #fff;
        height: 100%;
      }
    }
  }
}
</style>

```

## 第四章 用户登录前后端实现

### 4-1登录布局开发

登录页面没有复用主页面的布局，所以需要单独的布局，只需要实现

### 4-2登录交互开发

### 4-3用户登录后台实现