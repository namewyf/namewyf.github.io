---
date: 2024-11-11
category:
  - CategoryC
tag:
  - tag E
sticky: 20
---

# 后台管理项目
基于elementui、vue3的后台管理项目
<!-- more -->
## 前端架构设计

### 2-8 axios二次封装（下）
构造好request的封装函数后在main.js里进行全局挂载之后才能在组件进行全局使用
```js
import request from './uitils/request';
app.config.globalProperties.$request = request
```
>在js里request和request()是不同的，request是将request函数本身赋值给app.config.globalProperties.$request
如果说是request()则是先执行request然后将返回值赋值给app.config.globalProperties.$request

封装完成后，就能在组件里面调用了
```js
  mounted() {
    this.$request({
      method:'get',
      url:'/login',
      data:{
        name:'jack'
      }
    }).then((res)=>{
       console.log("res=",res);
    })
  }
```

为了更加方便的进行调用，我们还可以把request函数转换成一个对象，这个对象里有各种请求的方法  

request.js
```js
['get', 'post', 'put', 'delete', 'patch'].forEach((item) => {
    request[item] = (url, data, options) => {//options可以对请求的参数做一些额外的拓展，比如可以传mock:true,或者loading之类的东西
        return request({
            url,
            data,
            method: item,
            ...options
        })
    }
})
```
>1. 这个地方非常巧妙地把函数request转换为对象request，并且把多个属性添加到request对象里，属性的值是函数
>2. options可以对请求的参数做一些额外的拓展，比如可以传mock:true,或者loading:true之类的东西

login.vue
```js
  mounted() {
    this.$request.get('/login',{name:'jack'}).then((res)=>{
      console.log(res);
    })
  }
```

### 2-9 storage二次封装

#### storage的使用场景：  
1. 在用户进行登陆的时候，用来存储服务器发来的jwt(token)
2. 跨组件的数据共享，如果使用vuex只是一个数据共享，只是一个数据的管理，数据都只是存储在js内存里，当页面刷新的时候数据都会销毁，所以我们一般使用vuex结合local storage去做存储和管理
3. storage比cookie存储的数据的量更多的

#### local storage封装的目的：

定义不同的命名空间对变量名进行隔离，防止不同命名的冲突,但是local storage只能存储字符串，所以需要把对象转化为字符串再存储，这时候就可以使用JSON.stringify()方法来序列化对象，然后通过JSON.parse()方法来还原对象
>序列化（Serialization）是将数据结构或对象的状态转换为一个可存储或传输的格式的过程

>注意json语法的对象里面的key必须要加双引号(对，是必须是双引号)


utils/storage.js
```js
// Storage的封装

import config from "../config";
export default {
    setItem(key, val) {
        let storage = this.getStorage()
        storage[key] = val
        window.localStorage.setItem(config.namespace, JSON.stringify(storage));
    },
    getItem(key) {
        return this.getStorage()[key]
    },
    getStorage() {
        return JSON.parse(window.localStorage.getItem(config.namespace) || '{}')
    },
    clearItem(key) {
        let storage = this.getStorage()
        delete storage[key]//delete 是一个操作符，用于删除对象的属性
        window.localStorage.setItem(config.namespace, JSON.stringify(storage));
    },
    clearAll() {
        window.localStorage.clear()
    }
}
```

config/index.js
```js
export default {
    namespace: 'manager'
}
```

App.vue
```js
    mounted(){
      this.$storage.setItem('name','Tom')
    }
```

>注：在开发者工具中查看 localStorage 中存储的值时,确实会以对象的形式显示,即使你使用 JSON.stringify() 将其转换为字符串存储。  
这是因为开发者工具会尝试解析和显示存储的值的实际数据结构,而不仅仅是字符串形式。虽然 localStorage 中存储的是字符串,但开发者工具会尝试将其转换回原始的数据结构以便于查看和调试。  
所以即使你将对象转换为 JSON 字符串存储,开发者工具还是会尽量还原成对象的形式显示。这是开发者工具的一个特性,旨在为开发者提供更直观的数据查看体验。  
但实际上,在 localStorage 中存储的确是字符串形式的 JSON 数据。当你从 localStorage 中读取数据时,需要使用 JSON.parse() 将字符串转换回原始的对象或数组。  
总之,开发者工具的显示行为和 localStorage 的实际存储方式是不同的。这是开发者工具的一个特性,旨在为开发者提供更友好的数据查看体验。  