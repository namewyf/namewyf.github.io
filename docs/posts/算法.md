---
date: 2024-11-10
category:
  - CategoryC
tag:
  - tag E
sticky: true
excerpt: <p>算法题单</p>
---

# 算法灵神题单
<https://leetcode.cn/circle/discuss/RvFUtj/>

## 滑动窗口与双指针（定长/不定长/至多/至少/恰好/单序列/双序列/三指针）

### 定长滑动窗口

#### 643. 子数组最大平均数 I
<https://leetcode.cn/problems/maximum-average-subarray-i/description/>

1.不要预设数字是正数，比如下面这个max不能设置为0  
2.在第一次滑动窗口长度符合条件的时候，虽然不用进行判定，但是要设置值
```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findMaxAverage = function(nums, k) {
    let max //不能设置为0
    let sum = 0
    let left = 0
    for(let right = 0;right<nums.length;right++){
        sum+=nums[right]
        if(right<k-1){
            continue
        }else if(right === k-1){
            max = sum//在第一次滑动窗口长度符合条件的时候，虽然不用进行判定，但是要设置值
            continue
        }
        sum-=nums[left]
        left++
        max = max>sum?max:sum

    }
    return max/k||sum/k
};
```
#### 1343. 大小为 K 且平均值大于等于阈值的子数组数目
<https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/>

做判断的时候，不是=，而是===(经常犯错，但如果是编辑器的话是会纠错的)
```js
/**
 * @param {number[]} arr
 * @param {number} k
 * @param {number} threshold
 * @return {number}
 */
var numOfSubarrays = function(arr, k, threshold) {
    let right = 0,left = 0;
    let sum = 0,num = 0,avg;
    for(;left<arr.length;left++){//这里left和right实际上是写反了，但是不想改了，不影响
        sum+= arr[left]
        if(left<k-1){
            continue
        }else if(left === k-1){//做判断的时候，不是=，而是===
            avg = sum/k
            if(avg>=threshold){
                num++
            }
            continue
        }
        sum -= arr[right]
        right++
        avg = sum/k
        if(avg>=threshold){
            num++
        }
    }
    return num
};
```

### 不定长滑动窗口

### 单序列双指针

### 双序列双指针

### 三指针

## 链表、二叉树与一般树（前后指针/快慢指针/DFS/BFS/直径/LCA）

### 一、链表

### 二、二叉树
>学习递归，从二叉树开始。
晕递归的同学，请先看视频讲解【基础算法精讲 09】，欢迎点赞~
带着问题去做下面的题目：
>1. 一般来说，DFS 的递归边界是空节点。在什么情况下，要额外把叶子节点作为递归边界？
>2. 在什么情况下，DFS 需要有返回值？什么情况下不需要有返回值？
>3. 在什么情况下，题目更适合用自顶向下的方法解决？什么情况下更适合用自底向上的方法解决？

#### §2.1 遍历二叉树
##### 144. 二叉树的前序遍历
<https://leetcode.cn/problems/binary-tree-preorder-traversal/description/>

递归法  
这里不能return func(root.left)，一旦return就直接跳出func了（当使用递归的时候想清楚小问题，大问题是什么，这样才不会弄错）
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let out = []
    function func(root){
        if(root){
            out.push(root.val)
            if(root.left){
                func(root.left)//这里不能return func(root.left)，一旦return就直接跳出func了
            }
            if(root.right){
                func(root.right)
            }
            return out
        }else{
            return out
        }

    }
    func(root)
    return out
};
```

##### 94. 二叉树的中序遍历
<https://leetcode.cn/problems/binary-tree-inorder-traversal/submissions/571418917/>

递归法  
递归法实质上就是隐形地维护了一个栈
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let out = []
    function func(root) {
        if (root === null) {
            return null
        }
        if (root.left) {
            func(root.left)
        }
        out.push(root.val)
        if (root.right) {
            func(root.right)
        }
    }
    func(root)
    return out

};
```
迭代法  
1. 迭代法实质上就是把隐形维护的栈显化出来了  
2. 因为我们是不会修改二叉树的结构和值的，所以循环的时候，不是一步步循环的。我们不能想着每次while循环k就只移动一下，来设置循环，这样是不行的  
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let k = root
    let stack = []
    let out = []
    while(stack.length||k){//因为我们是不会修改二叉树的结构和值的，所以循环的时候，不是一步步循环的。我们不能想着每次while循环k就只移动一下，来设置循环，这样是不行的
        while(k){
            stack.push(k)
            k = k.left
        }
        k = stack.pop()
        out.push(k.val)
        k = k.right
    }
    return out
};
```

##### 872. 叶子相似的树
<https://leetcode.cn/problems/leaf-similar-trees/description/>


1. 不能使用arr1.join('')===arr2.join('')这样的判断方式，否则[1,2]和[12]会相等，对于数组可以使用toString的方式，比如[1,2,3]用toString方法转换后变成了"1,2,3"
>拓展
```js
const arr = [1, 2, 3];
arr.toString(); // "1,2,3"
Object.prototype.toString.call(arr); // "[object Array]"
const obj = { a: 1, b: 2 };
console.log(obj.toString()); // 输出: "[object Object]"
```
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {boolean}
 */
var leafSimilar = function(root1, root2) {
    let arr1 = [],arr2 = []
    function dfs(root,arr){
        if(root === null){
            return
        }else{
            if(root.left){
                dfs(root.left,arr)
            }
            if(root.right){
                dfs(root.right,arr)
            }
            if(root.left===null&&root.right===null){
                arr.push(root.val)
            }
        }
    }
    dfs(root1,arr1)
    dfs(root2,arr2)
    return arr1.toString()===arr2.toString()//不能使用arr1.join('')===arr2.join('')这样的判断方式，否则[1,2]和[12]会相等
};
```

##### LCP 44. 开幕式焰火

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var numColor = function(root) {
    let map = new Map()
    function func(root){
        if(root){
            if(map.has(root.val)){
                return func(root.left)+func(root.right)
            }else{
                map.set(root.val,1)
                return func(root.left)+func(root.right)+1
            }
        }else{
            return 0
        }
    }
    return func(root)
};
```

##### 404. 左叶子之和
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
    let sum = 0;
    function func(root){
        if(root){
            if(root.left&&!root.left.left&&!root.left.right){
                sum+=root.left.val
            }
            func(root.left)
            func(root.right)
        }else{
            return 0
        }
    }
    func(root)
    return sum
};
```

### 三、一般树